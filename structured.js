/*
 * StructuredJS provides an API for static analysis of code based on an abstract
 * syntax tree generated by Esprima (compliant with the Mozilla Parser
 * API at https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API).
 *
 * Dependencies: esprima.js, underscore.js
 */
(function(global) {
    /* Detect npm versus browser usage */
    var exports;
    var esprima;
    var _;

    // Cache all the structure tests
    var structureCache = {};

    // Cache the most recently-parsed code and tree
    var cachedCode;
    var cachedCodeTree;

    if (typeof module !== "undefined" && module.exports) {
        exports = module.exports = {};
        esprima = require("./external/esprima.js");
        _ = require("underscore");
    } else {
        exports = this.Structured = {};
        esprima = global.esprima;
        _ = global._;
    }

    if (!esprima || !_) {
        throw "Error: Both Esprima and UnderscoreJS are required dependencies.";
    }

    /**************************************************************************
     * LOGGING
     * 
     * Provides some neat functionality to trace code execution. Used for
     * debugging purposes.
     *************************************************************************/
    var L = {
        getParamNames: function(func) {
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,
                ARGUMENT_NAMES = /([^\s,]+)/g;

            var fnStr = func.toString().replace(STRIP_COMMENTS, '');
            var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
            if (result === null)
                result = [];
            return result;
        },

        functionName: function(fun) {
            var ret = fun.toString();
            ret = ret.substr('function '.length);
            ret = ret.substr(0, ret.indexOf('('));
            return ret;
        },

        traceCallNumber: 0,
        traceReturnValue: undefined,
        traceReturnBuffer: {},
        flushBuffer: function() {
            if (_.isEmpty(this.traceReturnBuffer)) {
                return;
            }

            // Show buffered values
            console.log(this.traceReturnBuffer, " -> ", this.traceReturnValue);

            // Reset buffer
            this.traceReturnBuffer = {};
        },

        bufferReturn: function(index, callData, value) {
            if (value !== this.traceReturnValue) {
                this.flushBuffer();
                this.traceReturnValue = value;
            }

            this.traceReturnBuffer[index] = callData;
        },

        trace: function(f, options) {
            options = options || {};

            var argNames = this.getParamNames(f);
            var name = options.name || this.functionName(f) || "anonymous";
            return function() {
                var index = this.traceCallNumber++;

                var args = Array.prototype.slice.call(arguments);

                this.flushBuffer();

                var logOutput = [];
                for (var i = 0; i < args.length; i++) {
                    logOutput.push("\n\t" + (argNames[i] || "UNDEFINED") + ": ");
                    try {
                        logOutput.push(deepClone(args[i]));
                    } catch (e) { // Cloning failed
                        logOutput.push(args[i]);
                    }
                }

                console.log.apply(console, [(name || "") + "("].concat(logOutput).concat(["\n) [" + index + "]"]));

                var r = f.apply(null, arguments);

                this.bufferReturn(index, {
                    "name": name,
                    "args": logOutput
                }, r); // Out

                return r;
            }.bind(this)
        },

    };

    /**************************************************************************
     * AUXILIARY FUNCTIONS
     *************************************************************************/
    var eachNodeDo = function(node, fn) {
        if (typeof(fn) !== "function") {
            throw new Error("ARGUMENT ERROR: 'fn' is not a function");
        }

        if (!_.isObject(node) || _.isArray(node)) {
            return;
        }

        for (var key in node) {
            if (!node.hasOwnProperty(key)) {
                continue; // Inherited property
            }

            fn(node[key], key);
        }
    };

    var eachNodeSkipArrayDo = function(node, fn) {
        if (!fn) {
            console.warn("ARGUMENT ERROR in eachNodeSkipArrayDo: Did you forget to pass fn?");
        }

        if (_.isArray(node)) {
            node = {
                _: node
            };
        }

        eachNodeDo(node, function(node, name) {
            if (_.isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                    fn(node[i]);
                }
            } else {
                fn(node);
            }
        });
    };

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    /**************************************************************************
     * STRUCTURE PREPROCESSING
     * 
     * Simplifies the structure tree into a consistent format, so that minor
     * differences don't break the match completly
     *************************************************************************/
    function parseStructure(structure) {
        if (typeof structure === "object") {
            return deepClone(structure);
        }

        if (structureCache[structure]) {
            return JSON.parse(structureCache[structure]);
        }

        // Wrapped in parentheses so function() {} becomes valid Javascript.
        var fullTree = esprima.parse("(" + structure + ")");

        if (fullTree.body[0].expression.type !== "FunctionExpression" ||
            !fullTree.body[0].expression.body) {
            throw "Poorly formatted structure code";
        }

        var tree = fullTree.body[0].expression.body;
        structureCache[structure] = JSON.stringify(tree);
        return tree;
    }

    /*
     * Returns a tree parsed out of the structure. The returned tree is an
     *    abstract syntax tree with wildcard properties set to undefined.
     *
     * structure is a specification looking something like:
     *        function structure() {if (_) { var _ = 3; }}
     *    where _ denotes a blank (anything can go there),
     *    and code can go before or after any statement (only the nesting and
     *        relative ordering matter).
     */
    function parseStructureWithVars(structure) {
        var tree = parseStructure(structure);
        foldConstants(tree);
        tree = standardizeTree(tree);
        return tree;
    }

    /*
     * Constant folds the syntax tree
     */
    function foldConstants(tree) {
        for (var key in tree) { /* jshint forin:false */
            if (!tree.hasOwnProperty(key)) {
                continue; // Inherited property
            }

            var ast = tree[key];
            if (_.isObject(ast)) {
                foldConstants(ast);

                /*
                 * Currently, we only fold + and - applied to a number literal.
                 * This is easy to extend, but it means we lose the ability to match
                 * potentially useful expressions like 5 + 5 with a pattern like _ + _.
                 */
                /* jshint eqeqeq:false */
                if (ast.type == esprima.Syntax.UnaryExpression) {
                    var argument = ast.argument;
                    if (argument.type === esprima.Syntax.Literal &&
                        _.isNumber(argument.value)) {
                        if (ast.operator === "-") {
                            argument.value = -argument.value;
                            tree[key] = argument;
                        } else if (ast.operator === "+") {
                            argument.value = +argument.value;
                            tree[key] = argument;
                        }
                    }
                }
            }
        }
    }

    /*
     * return true if n2 < n1 (according to relatively arbitrary criteria)
     */
    function shouldSwap(n1, n2) {
        if (n1.type < n2.type) { //Sort by node type if different
            return false;
        } else if (n1.type > n2.type) {
            return true;
        } else if (n1.type === "Literal") { //Sort by value if they're literals
            return n1.raw > n2.raw;
        } else { //Otherwise, loop through the properties until a difference is found and sort by that
            for (var k in n1) {
                if (n1[k].hasOwnProperty("type") && n1[k] !== n2[k]) {
                    return shouldSwap(n1[k], n2[k]);
                }
            }
        }
    }

    function standardizeTree(tree) {
        if (!tree) {
            return tree;
        }
        var r = deepClone(tree);
        switch (tree.type) {

            case "BinaryExpression":
                if (_.contains(["*", "+", "===", "!==", "==", "!=", "&", "|", "^"], tree.operator)) {
                    if (shouldSwap(tree.left, tree.right)) {
                        r.left = standardizeTree(tree.right);
                        r.right = standardizeTree(tree.left);
                    } else {
                        r.left = standardizeTree(tree.left);
                        r.right = standardizeTree(tree.right);
                    }
                } else if (tree.operator[0] === ">") {
                    r.operator = "<" + tree.operator.slice(1);
                    r.left = standardizeTree(tree.right);
                    r.right = standardizeTree(tree.left);
                }
                break;

            case "LogicalExpression":
                if (_.contains(["&&", "||"], tree.operator) &&
                    shouldSwap(tree.left, tree.right)) {
                    r.left = standardizeTree(tree.right);
                    r.right = standardizeTree(tree.left);
                }
                break;

            case "AssignmentExpression":
                if (_.contains(["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|="], tree.operator)) {
                    var l = standardizeTree(tree.left);
                    r = {
                        type: "AssignmentExpression",
                        operator: "=",
                        left: l,
                        right: {
                            type: "BinaryExpression",
                            operator: tree.operator.slice(0, -1),
                            left: l,
                            right: standardizeTree(tree.right)
                        }
                    };
                } else {
                    r.left = standardizeTree(r.left);
                    r.right = standardizeTree(r.right);
                }
                break;

            case "UpdateExpression":
                if (_.contains(["++", "--"], tree.operator)) {
                    var l = standardizeTree(tree.argument);
                    r = {
                        type: "AssignmentExpression",
                        operator: "=",
                        left: l,
                        right: {
                            type: "BinaryExpression",
                            operator: tree.operator[0],
                            left: l,
                            right: {
                                type: "Literal",
                                value: 1,
                                raw: "1"
                            }
                        }
                    };
                }
                break;

            case "VariableDeclaration":
                if (tree.kind === "var") {
                    r = [deepClone(tree)];
                    for (var i in tree.declarations) {
                        if (tree.declarations[i].type === "VariableDeclarator" &&
                            tree.declarations[i].init !== null) {
                            r.push({
                                type: "ExpressionStatement",
                                expression: {
                                    type: "AssignmentExpression",
                                    operator: "=",
                                    left: tree.declarations[i].id,
                                    right: standardizeTree(tree.declarations[i].init)
                                }
                            });
                            r[0].declarations[i].init = null;
                        }
                    }
                }
                break;

            case "Literal":
                r.raw = tree.raw
                    .replace(/^(?:\"(.*?)\"|\'(.*?)\')$/, function(match, p1, p2) {
                        return "\"" + ((p1 || "") + (p2 || ""))
                            .replace(/"|'/g, "\"") + "\"";
                    });
                break;

            case "Program":
                r.type = "BlockStatement";
                // Fall through

            default:
                for (var key in tree) {
                    if (!tree.hasOwnProperty(key) || !_.isObject(tree[key])) {
                        continue;
                    }

                    if (_.isArray(tree[key])) {
                        var ar = [];
                        for (var i in tree[key]) { /* jshint forin:false */
                            ar = ar.concat(standardizeTree(tree[key][i]));
                        }
                        r[key] = ar;
                    } else {
                        if (key === "value" || (tree[key] !== undefined && tree[key] !== null)) {
                            r[key] = standardizeTree(tree[key]);
                        }
                    }
                }
        }
        return r;
    }

    /*
     * Returns whether the structure node is intended as a wildcard node, which
     * can be filled in by anything in others' code.
     */
    function isWildcard(node) {
        return node.name && node.name === "_";
    }

    /* Returns whether the structure node is intended as a wildcard variable. */
    function isWildcardVariable(node) {
        return (node.name && _.isString(node.name) && node.name.length >= 2 &&
            node.name[0] === "$");
    }


    /**************************************************************************
     * MATCHING CACHE
     * 
     * Every time we compare two objects, we save the results to reuse later.
     * This provides an important speed up.
     * 
     * The first time we find an object, we tag it with a 'structuredID' so that
     * we can easily recognize it later on. 
     * 
     * TODO: Fix 'structuredID' properties sometimes leaking to user callbacks
     * TODO: Improve algorithm to tag objects with the correct 'structuredID'
     *************************************************************************/
    function deepCompare(a, b) {
        if (a === b) {
            return true;
        }

        if (!_.isObject(a) || !_.isObject(b)) {
            return false;
        }

        for (var key in a) {
            if (key === "structuredID") continue;

            if (!a.hasOwnProperty(key)) {
                continue;
            }

            if (!deepCompare(a[key], b[key])) {
                return false;
            }
        }

        for (var key in b) {
            if (key === "structuredID") continue;
            if (!b.hasOwnProperty(key)) {
                continue;
            }

            if (!deepCompare(a[key], b[key])) {
                return false;
            }
        }

        return true;
    }

	// Stores an index for each object. Equal objects have equal indices.
    var indexCache = [];
    var indexNode = function(node) {
        if (!_.isObject(node)) {
            return;
        }

        if (node.structuredID !== undefined) return;

        for (var i = 0; i < indexCache.length; i++) {
            var cacheNode = indexCache[i];
            //if (_.isEqual(cacheNode, node)) {
            if (deepCompare(cacheNode, node)) {
                node.structuredID = i;
                return;
            }
        }

        indexCache.push(deepClone(node));
        node.structuredID = indexCache.length - 1;
    };

    var indexRecursively = function(tree) {
        indexNode(tree);
        eachNodeSkipArrayDo(tree, indexRecursively);
    };

	
    var cacheHits = [0, 0]; // Statistics for cache hits
    var matchCache = [];
    var getFromCache = function(currentNode, toFind) {
        if (!currentNode || !toFind) {
            throw "ARGUMENT ERROR: Cannot cache item because it's not an object!";
        }
        cacheHits[0]++;

        if (currentNode.structuredID === undefined) {
            console.log(currentNode);
            throw new Error("ARGUMENT ERROR: Structure has not been indexed!");
        }

        if (toFind.structuredID === undefined) {
            console.log(toFind);
            throw new Error("ARGUMENT ERROR: Structure has not been indexed!");
        }

        var c1 = matchCache[toFind.structuredID];

        if (c1) {
            if (c1[currentNode.structuredID] !== undefined) {
                cacheHits[1]++;
            }
            return c1[currentNode.structuredID];
        }
    };

    var saveToCache = function(currentNode, toFind, result) {
        if (!_.isObject(toFind) || !_.isObject(currentNode)) {
            throw new Error("ARGUMENT ERROR: not an object!");
        }

        if (!matchCache[toFind.structuredID]) {
            matchCache[toFind.structuredID] = [];
        }

        matchCache[toFind.structuredID][currentNode.structuredID] = result;
        return result;
    };


    /**************************************************************************
     * RESULTS HANDLING
     * 
     * A result looks like this: 
     * 	{
     * 		wVars: [{
     * 			$a: 1,
     * 			$b: 2
     * 		}, {
     * 			$a: 3,
     * 			$b: 2
     * 		}]
     * 	}
     * 
     * Each element in the 'wVars' array contains one of the possibilities for 
     * the user variable's values. 'wVars' is true if it didn't find any user
     * variables yet. 
     * 
     * These functions simplify the task of merging results where both have to 
     * pass (AND) or just one has to pass (OR).
     *************************************************************************/
    var matchesAll = {
        wVars: true
    };
    var matchesNone = false;

    function orResults(a, b) {
        if (!a) {
            return b;
        }

        if (!b) {
            return a;
        }

        return {
            wVars: orWVarsResults(a.wVars, b.wVars)
        };
		
		function orWVarsResults(a, b) {
			if (a === true || b === true) {
				return true;
			}

			return a.concat(b);
		};
    }

    function andResults(a, b) {
        if (!a || !b) {
            return false;
        }

        var wVars = andWVarsResults(a.wVars, b.wVars);
        if (wVars.length === 0) {
            return false;
        }

        return {
            wVars: wVars
        }
		
		function andWVarsResults(a, b) {
			if (a === true) return b;
			if (b === true) return a;

			var result = [];
			for (var i = 0; i < a.length; i++) {
				for (var j = 0; j < b.length; j++) {
					var merged = mergeRules(a[i], b[j]);
					if (merged) {
						result.push(merged);
					}
				}
			}

			return result;
			
			function mergeRules(a, b) {
				var result = {};
				for (var key in a) {
					if (b[key] && a[key].structuredID !== b[key].structuredID) {
						return matchesNone;
					}

					result[key] = a[key];
				}

				for (var key in b) {
					if (!a[key]) {
						result[key] = b[key];
					}
				}

				return result;
			};
		}
    }

    var makeGroup = function(key, value) {
        var data = {};
        data[key] = value;

        return {
            wVars: [data]
        };
    };


    /**************************************************************************
     * STRUCTURED CORE
     * 
     * Provides the functionality to look for one AST inside another AST
     * Returns all possible matches, with the format described in the RESULTS
     * section
     *************************************************************************/
	
	// Looks for 'toFind' in 'currentNode' properties
    function searchInside(currentNode, toFind) {
        var result = matchesNone;
        for (var key in currentNode) {
            if (!currentNode.hasOwnProperty(key)) continue;
            if (key === "structuredID") continue;

            var r = matchTree(currentNode[key], toFind);
            if (r === matchesAll) return matchesAll
            else result = orResults(result, r);
        }

        return result;
    }

	// Checks if all the properties in 'toFind' object match properties in 'currentNode' object
    function checkAll(currentNode, toFind) {
        var result = matchesAll;
        for (var key in toFind) {
            if (!toFind.hasOwnProperty(key)) continue;
            if (key === "structuredID") continue;

            var r = matchTree(currentNode[key], toFind[key]);
            if (r === matchesNone) return matchesNone
            else result = andResults(result, r);
        }

        return result;
    }

	// Matches AST 'toFind' against AST 'currentNode', returns all possible matches.
	// Chech the RESULTS section for the return format
    function matchTree(currentNode, toFind) {
        if (_.isArray(toFind)) {
            if (toFind.length === 0) {
                return matchesAll;
            }

            if (toFind.length === 1) {
                return matchTree(currentNode, toFind[0]);
            }

            if (_.isArray(currentNode)) {
                if (currentNode.length === 0) {
                    return matchesNone;
                }

                var result = matchesNone;
			
                // See what we can find in the first element
                var currentHead = currentNode[0];
                var currentTail = currentNode.slice(1);

                for (var i = 0; i <= toFind.length; i++) {
                    var findHead = toFind.slice(0, i);
                    var findTail = toFind.slice(i);

                    var headResult = matchTree(currentHead, findHead);
                    var tailResult = matchTree(currentTail, findTail);

					// If the head already fails, looking for even more elements also fails
                    if (headResult === matchesNone) {
                        break;
                    }

                    var thisResult = andResults(headResult, tailResult);

					// If we already have a complete match, halt early
                    if (thisResult === matchesAll) return matchedAll;

                    result = orResults(result, thisResult);
                }

                return result;
            } else if (_.isObject(currentNode)) {
                return searchInside(currentNode, toFind);
            }

            return matchesNone;
        }

        if (_.isArray(currentNode)) {
            var result = matchesNone;

            for (var i = 0; i < currentNode.length; i++) {
                result = orResults(result, matchTree(currentNode[i], toFind));
            }

            return result;
        }

        if (_.isObject(toFind)) {
            if (_.isObject(currentNode)) {
                return matchObjectTree(currentNode, toFind);
            }

            return matchesNone;
        }

        return (toFind === currentNode || toFind === null) ? 	matchesAll :
																matchesNone;
    }

	// Helper to matchTree, matches object vs object
    function matchObjectTree(currentNode, toFind) {
		if (!_.isObject(toFind) || _.isArray(toFind) 
		|| 	!_.isObject(currentNode) || _.isArray(currentNode)) {
            throw new Error("Argument error: Not an object!");
        }
		
        var cached;
        if ((cached = getFromCache(currentNode, toFind)) !== undefined) {
            return cached;
        }

        if (isWildcard(toFind)) {
            return saveToCache(currentNode, toFind, matchesAll);
        }

        if (isWildcardVariable(toFind)) {
            var result = matchesNone;
            var getNode = function(node) {
                if (_.isObject(node)) {
                    result = orResults(result, makeGroup(toFind.name, node));
                    eachNodeSkipArrayDo(node, getNode);
                }
            }

            getNode(currentNode);

            return saveToCache(currentNode, toFind, result);
        }

        // Check if all of the 'toFind' properties match
        var result = checkAll(currentNode, toFind);

        // Also check recursively inside 'currentNode'
        result = orResults(result, searchInside(currentNode, toFind));

        return saveToCache(currentNode, toFind, result);
    };

    /**************************************************************************
     * INTERFACE
     *************************************************************************/
    /*
     * Introspects a callback to determine it's parameters and then
     * produces a constraint that contains the appropriate variables and callbacks.
     *
     * This allows a much terser definition of callback function where you don't have to
     * explicitly state the parameters in a separate list
     */
    function makeConstraint(callback) {
        var paramText = /^function [^\(]*\(([^\)]*)\)/.exec(callback)[1];
        var params = parseCallbackNames(paramText);

        return {
            variables: params,
            fn: callback
        };
    }

    function parseCallbackNames(str) {
        var params = str.match(/[$_a-zA-z0-9]+/g);

        for (var key in params) {
            if (params[key][0] !== "$") {
                console.warn("Invalid parameter in constraint (should begin with a '$'): ", params[key]);
                return null;
            }
        }

        return params;
    }

    // [{names: ["$a", "$b"], fn: function (a, b) {}}]
    function extractSingleCallback(rawCallback, paramText) {
        if (rawCallback instanceof Function) {
            if (typeof(paramText) === "number") {
                return makeConstraint(rawCallback);
            }

            return {
                variables: parseCallbackNames(paramText),
                fn: rawCallback
            }
        }

        if (_.isObject(rawCallback)) {
            if (rawCallback.variables && rawCallback.fn) {
                return rawCallback;
            }
        }

        console.warn(rawCallback);
        throw new Error("ARGUMENT ERROR: Invalid callback!");
    }

    function extractAllCallbacks(rawCallbacks) {
        if (!rawCallbacks) {
            return [];
        }

        if (_.isObject(rawCallbacks)) {
            if (!rawCallbacks.variables || !rawCallback.fn) {
                return _.map(rawCallbacks, extractSingleCallback);
            }
        }

        return [extractSingleCallback(rawCallbacks)];
    }

    /*
     * Returns true if the code (a string) matches the structure in rawStructure
     * Throws an exception if code is not parseable.
     *
     * Example:
     *     var code = "if (y > 30 && x > 13) {x += y;}";
     *     var rawStructure = function structure() { if (_) {} };
     *     match(code, rawStructure);
     *
     * options.varCallbacks is an object that maps user variable strings like
     *  "$myVar", "$a, $b, $c" etc to callbacks. These callbacks receive the
     *  potential Esprima structure values assigned to each of the user
     *  variables specified in the string, and can accept/reject that value
     *  by returning true/false. The callbacks can also specify a failure
     *  message instead by returning an object of the form
     *  {failure: "Your failure message"}, in which case the message will be
     *  returned as the property "failure" on the varCallbacks object if
     *  there is no valid match. A valid matching requires that every
     *  varCallback return true.
     *
     * Advanced Example:
     *   var varCallbacks = [
     *     function($foo) {
     *         return $foo.value > 92;
     *     },
     *     function($foo, $bar, $baz) {
     *         if ($foo.value > $bar.value) {
     *            return {failure: "Check the relationship between values."};
     *         }
     *         return $baz.value !== 48;
     *     }
     *   ];
     *   var code = "var a = 400; var b = 120; var c = 500; var d = 49;";
     *   var rawStructure = function structure() {
     *       var _ = $foo; var _ = $bar; var _ = $baz;
     *   };
     *   match(code, rawStructure, {varCallbacks: varCallbacks});
     */
    function match(code, rawStructure, options) {
        options = options || {};
        // Many possible inputs formats are accepted for varCallbacks
        // Constraints can be:
        // 1. a function (from which we will extract the variables)  
        // 2. an objects (which already has separate .fn and .variables properties)
        //
        // It will also accept a list of either of the above (or a mix of the two).

        var varCallbacks = extractAllCallbacks(options.varCallbacks);

        // Note: After the parse, structure contains object references into
        // wildcardVars[values] that must be maintained. So, beware of
        // JSON.parse(JSON.stringify), etc. as the tree is no longer static.
        var structure = parseStructureWithVars(rawStructure);

        // Cache the parsed code tree, or pull from cache if it exists
        var codeTree;
        if (cachedCode === code) {
            codeTree = cachedCodeTree;
        } else {
            codeTree = (typeof code === "object" ? deepClone(code) :
                esprima.parse(code)
            )
            foldConstants(codeTree);
            codeTree = standardizeTree(codeTree);

            // Save for next match
            cachedCode = code;
            cachedCodeTree = codeTree;

            // Reset cache
            matchCache = [];
            indexCache = [];
            indexRecursively(codeTree);
        }

        indexRecursively(structure);
        var result = matchTree(codeTree, structure);

        if (!result) {
            return {
                matched: false,
                failedOn: -1
            };
        }

        var wVars = result.wVars;

        if (wVars === true) {
            return checkUserVarCallbacks({}, varCallbacks);
        }

        var closestMatch = {
            matched: true,
            failedOn: -1
        };
        for (var i = 0; i < wVars.length; i++) {
            var singleResult = checkUserVarCallbacks(wVars[i], varCallbacks);

            if (singleResult.matched) {
                return singleResult;
            }

            if (singleResult.failedOn > closestMatch.failedOn) {
                closestMatch = singleResult;
            }
        }

        //console.log("Cache was used " + (100 * cacheHits[1] / cacheHits[0]).toFixed(2)+ "% of the time. [" + cacheHits[1] + "/" + cacheHits[0] + "]");
        return closestMatch;
    }

    function getWValues(wVars) {
        if (!wVars) return {};

        var newWVars = {};
        for (var key in wVars) {
            newWVars[key] = deepClone(indexCache[wVars[key].structuredID]);
        }

        return newWVars;
    }

    /*
     * Checks the user-defined variable callbacks and returns a boolean for
     *   whether or not the wVars assignment of the wildcard variables results
     *   in every varCallback returning true as required.
     *
     * If any varCallback returns false, this function also returns false.
     *
     * Format of varCallbacks: An object containing:
     *     keys of the form: "$someVar" or "$foo, $bar, $baz" to mimic an
     *        array (as JS keys must be strings).
     *     values containing function callbacks. These callbacks must return
     *        true/false. They may alternately return an object of the form
     *        {failure: "The failure message."}. If the callback returns the
     *        failure object, then the relevant failure message will be returned
     *        via varCallbacks.failure.
     *        These callbacks are passed a parameter list corresponding to
     *         the Esprima parse structures assigned to the variables in
     *         the key (see example).
     *
     * Example varCallbacks object:
     *    {
     *     "$foo": function(fooObj) {
     *         return fooObj.value > 92;
     *     },
     *     "$foo, $bar, $baz": function(fooObj, barObj, bazObj) {
     *         if (fooObj.value > barObj.value) {
     *            return {failure: "Check the relationship between values."}
     *         }
     *         return bazObj !== 48;
     *     }
     *   }
     */
    function checkUserVarCallbacks(wVars, varCallbacks) {
        // Clone at the beginning and reuse the same object to allow user 
        // changes
        wVars = getWValues(wVars);

        for (var i = 0; i < varCallbacks.length; i++) {
            // Property strings may be "$foo, $bar, $baz" to mimic arrays.
            // Trim whitespace
            var varNames = _.map(varCallbacks[i].variables, stringLeftTrim);
            var varValues = _.map(varNames, function(varName) {
                // If the var name is in the structure, then it will always
                // exist in wVars.values after we find a match prior to
                // checking the var callbacks. So, if a variable name is not
                // defined here, it is because that var name does not exist in
                // the user-defined structure.
                if (!_.has(wVars, varName)) {
                    console.error("Callback var " + varName + " doesn't exist");
                    return undefined;
                }
                // Convert each var name to the Esprima structure it has
                // been assigned in the parse. Make a deep copy.
                return wVars[varName];
            });

            // Call the user-defined callback, passing in the var values as
            // parameters in the order that the vars were defined in the
            // property string.

            var result = varCallbacks[i].fn.apply(null, varValues);
            if (!result) {
                return {
                    matched: false,
                    failedOn: i
                };
            } else if (_.isObject(result)) {
                if (_.has(result, "failure")) {
                    return {
                        matched: false,
                        failedOn: i,
                        failure: result.failure
                    };
                } else if (_.has(result, "extend")) {
                    // We allow adding/changing value data, so that users can
                    // define new variables on one constraint and use it after
                    _.extend(wVar, result.extend);
                }
            }
        }

        return {
            matched: true,
            vars: wVars
        };

        /* Trim is only a string method in IE9+, so use a regex if needed. */
        function stringLeftTrim(str) {
            if (String.prototype.trim) {
                return str.trim();
            }
            return str.replace(/^\s+|\s+$/g, "");
        }
    }

    /*
     * Takes in a string for a structure and returns HTML for nice styling.
     * The blanks (_) are enclosed in span.structuredjs_blank, and the
     * structured.js variables ($someVar) are enclosed in span.structuredjs_var
     * for special styling.
     *
     * See pretty-display/index.html for a demo and sample stylesheet.
     *
     * Only works when RainbowJS (http://craig.is/making/rainbows) is
     * included on the page; if RainbowJS is not available, simply
     * returns the code string. RainbowJS is not available as an npm
     * module.
     */
    function prettyHtml(code, callback) {
        if (!Rainbow) {
            return code;
        }
        Rainbow.color(code, "javascript", function(formattedCode) {
            var output = ("<pre class='rainbowjs'>" +
                addStyling(formattedCode) + "</pre>");
            callback(output);
        });
    }

    /*
     * Helper function for prettyHtml that takes in a string (the formatted
     * output of RainbowJS) and inserts special StructuredJS spans for
     * blanks (_) and variables ($something).
     *
     * The optional parameter maintainStyles should be set to true if the
     * caller wishes to keep the class assignments from the previous call
     * to addStyling and continue where we left off. This parameter is
     * valuable for visual consistency across different structures that share
     * variables.
     */
    function addStyling(code, maintainStyles) {
        if (!maintainStyles) {
            addStyling.styleMap = {};
            addStyling.counter = 0;
        }
        // First replace underscores with empty structuredjs_blank spans
        // Regex: Match any underscore _ that is not preceded or followed by an
        // alphanumeric character.
        code = code.replace(/(^|[^A-Za-z0-9])_(?![A-Za-z0-9])/g,
            "$1<span class='structuredjs_blank'></span>");
        // Next replace variables with empty structuredjs_var spans numbered
        // with classes.
        // This regex is in two parts:
        //  Part 1, delimited by the non-capturing parentheses `(?: ...)`:
        //    (^|[^\w])\$(\w+)
        //    Match any $ that is preceded by either a 'start of line', or a
        //    non-alphanumeric character, and is followed by at least one
        //    alphanumeric character (the variable name).
        //  Part 2, also delimited by the non-capturing parentheses:
        //      ()\$<span class="function call">(\w+)<\/span>
        //      Match any function call immediately preceded by a dollar sign,
        //      where the Rainbow syntax highlighting separated a $foo()
        //      function call by placing the dollar sign outside.
        //      the function call span to create
        //      $<span class="function call">foo</span>.
        // We combine the two parts with an | (an OR) so that either matches.
        // The reason we do this all in one go rather than in two separate
        // calls to replace is so that we color the string in order,
        // rather than coloring all non-function calls and then going back
        // to do all function calls (a minor point, but otherwise the
        // interactive pretty display becomes jarring as previous
        // function call colors change when new variables are introduced.)
        // Finally, add the /g flag for global replacement.
        var regexVariables = /(?:(^|[^\w])\$(\w+))|(?:\$<span class="function call">(\w+)<\/span>)/g;
        return code.replace(regexVariables,
            function(m, prev, varName, fnVarName) {
                // Necessary to handle the fact we are essentially performing
                // two regexes at once as outlined above.
                prev = prev || "";
                varName = varName || fnVarName;
                var fn = addStyling;
                // Assign the next available class to this variable if it does
                // not yet exist in our style mapping.
                if (!(varName in fn.styleMap)) {
                    fn.styleMap[varName] = (fn.counter < fn.styles.length ?
                        fn.styles[fn.counter] : "extra");
                    fn.counter += 1;
                }
                return (prev + "<span class='structuredjs_var " +
                    fn.styleMap[varName] + "'>" + "</span>");
            }
        );
    }
    // Store some properties on the addStyling function to maintain the
    // styleMap between runs if desired.
    // Right now just support 7 different variables. Just add more if needed.
    addStyling.styles = ["one", "two", "three", "four", "five", "six",
        "seven"
    ];
    addStyling.styleMap = {};
    addStyling.counter = 0;

    function getSingleData(node, data) {
        if (!node || node.type !== "Identifier") {
            return;
        }

        if (node.name === "_") {
            if (!data._ || data._.length === 0) {
                throw "No _ data available.";
            }

            return data._.shift();
        } else if (node.name && node.name.indexOf("$") === 0) {
            var name = node.name.slice(1);

            if (!data.vars || !(name in data.vars)) {
                throw "No vars available.";
            }

            return data.vars[name];
        }
    }

    function getGlobData(node, data) {
        var check = node && node.expression || node;

        if (!check || check.type !== "Identifier") {
            return;
        }

        if (check.name === "glob_") {
            if (!data._ || data._.length === 0) {
                throw "No _ data available.";
            }

            return data._.shift();
        } else if (check.name && check.name.indexOf("glob$") === 0) {
            var name = check.name.slice(5);

            if (!data.vars || !(name in data.vars)) {
                throw "No vars available.";
            }

            return data.vars[name];
        }
    }

    function injectData(node, data) {
        if (!node) {
            return node;
        }

        for (var prop in node) { /* jshint forin:false */
            if (!node.hasOwnProperty(prop)) {
                continue;
            }

            if (node[prop] && typeof node[prop] === "object" && "length" in node[prop]) {
                for (var i = 0; i < node[prop].length; i++) {
                    var globData = getGlobData(node[prop][i], data);

                    if (globData) {
                        node[prop].splice.apply(node[prop], [i, 1].concat(globData));
                        break;
                    } else if (typeof node[prop][i] === "object") {
                        var singleData = getSingleData(node[prop][i], data);

                        if (singleData) {
                            node[prop][i] = singleData;
                        } else if (typeof node[prop][i] === "object") {
                            injectData(node[prop][i], data);
                        }
                    }
                }
            } else {
                var singleData = getSingleData(node[prop], data);

                if (singleData) {
                    node[prop] = singleData;
                } else if (typeof node[prop] === "object") {
                    injectData(node[prop], data);
                }
            }
        }

        return node;
    }

    function _match(code, rawStructure, options) {
        var result = match(code, rawStructure, options);

        if (result.matched) {
            return result;
        }

        if (result.failure) {
            options.varCallbacks.failure = result.failure;
        }

        return false;
    }

    exports.match = _match;
    exports.matchNode = function(code, rawStructure, options) {
        options = options || {};
        options.single = true;
        return match(code, rawStructure, options);
    };
    exports.injectData = function(node, data) {
        node = parseStructure(node);
        data = deepClone(data);
        return injectData(node, data);
    };
    exports.prettify = prettyHtml;



})(typeof window !== "undefined" ? window : global);